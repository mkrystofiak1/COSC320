Author: Mitchell Krystofiak
Date: March 25, 2021

Task 2c
	This program makes sense because it pretty much acts like a giant blender! It takes an arbritrary value and gives it such a 
	crazy remote value by using the theoretical hashing multiplication method, and gives it a unique value.

1.
	My approach to this was very simple, for the hash function, follow as closely as possible to the lab's explanation. The only
	reason I struggled in the beginning is because I didn't understand the bitwise operators at first. Once I understood what
	they were doing, I was able to work it out properly. For the string hashing, I used a similar method for both 1 and 2, and 
	used random primes (10 digits) to give it a remote, unique value. Then, the main program was a series of test cases: small 
	numbers, larger numbers, small strings, large strings, and character wise identical strings, just to make sure the hash
	was unique (and it was). I also implemented the fstream library to read in sample text documents to test my program on larger
	strings.

2.	
	String 1: This function parses through the string using a while loop, and adds up the sum of all the values of each character.
		  It multiples the vlaue by a large prime number and mods it by the index squared + 1. It then returns the sum 
		  multiplied by the index and modded out by the prime number.

	String 2: This function functions in the same way as string 1's function, but this time, we use another prime number to get an
		  even more remote value and mod out by the other one.

3.
	The code seems very efficient already! It processes the huge strings and small strings, huge numbers and small numbers, and 
	even text documents! I'm very proud of this code, especially because I didn't understand anything about what I was doing when
	it was first assigned, and now, it reflects my growth. In terms of the string hashing functions, THERE ARE SO MANY WAYS to 
	hash a string. I could have multiplied by tons of prime numbers, modded tons of prime numbers, divided, added, etc. The only
	thing I would improve about this program is user input. Being able to put in specific test cases would be ideal for testing
	purposes, or say you want to hash a specific thing, boom just throw it in this program and here you go! Also, the large 
	document could also be made longer and longer, to fully test the capabilities of this function. I could have also added 
	a function which checks how many collisions are possible via these algorithms. I would like to know if they are full proof
	or if there is a common flaw which produces many similar hashes. In theory, there should be no collisions.
